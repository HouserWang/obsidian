---
created: 2025-12-17 13:16
tags:
  - redis
  - io多路复用
  - brag-doc
category: Middleware
tech_stack:
  - Redis
status: 🟢 掌握
---

# 🚀 技术沉淀: redis读写请求全链路

## 1. 第一性原理 (The "Why" & "How")
> 💡 **核心机制拆解**：

- **底层机制**：smart redis、单reactor/多线程网络io、同步aof buf和pagecache/异步刷盘、同步slave buf/异步复制replica log
- **设计哲学**：[[reactor模型]]、append-Only log、异步刷盘与异步复制
- **关键细节**：
    - 客户端连接3次握手->redis主线程event loop epoll_wait监控到accept事件->epoll_ctl注册一个新的read事件
    - 数据到达网卡->epoll_wait唤醒主线程->主线程分配给io thread->io thread读取数据，从内核buffer复制到input buffer，解析数据
    - 客户端发送数据->触发读事件->redis网络io线程池拿出子线程来读取数据->子线程对数据进行解码编码操作解析出该redis命令
    - 写入aof buf和pagecache->写入slave buffer->异步的刷盘和异步的复制
    - 主线程把返回写入client的output buffer,io线程把output buffer write到内核，内核再复制到网卡发送给client

## 2. 横向对比 (The Trade-off)
> ⚖️ **架构师视角**：没有最好的技术，只有最适合的权衡。

| 维度        | 当前技术                   | 对标技术 (Caffeine) |
| :-------- | :--------------------- | :-------------- |
| **一致性**   | 多台应用服务可保证数据一致性         | 多台应用服务无法保证数据一致性 |
| **IO 模型** | 单reactor+网络io线程池       | 无网络io           |
| **适用场景**  | 缓存，分布式锁，redis数据结构的适合场景 | 不变的一些数据，或者降级用   |

- **核心差异点**：redis是分布式的并且和应用不同的进程，可以减轻应用服务的内存压力，分布式可以保证高可用，单线程内存可以保证性能，而Caffeine和应用同生同死，多台应用机器也无法保证数据的一致性。

## 3. 业务落地 (The Value)
> 💼 **场景化应用**：缓存、例如库存等的一些高并发场景、分布式锁、

- **痛点描述**：
- **解决方案**：...
- **收益/价值**：...

## 4. 简历话术预案 (Resume Snippet)
> 📝 **降维打击**：明年写简历时，直接复制这一段。
> *格式建议：掌握 [技术原理]，在 [业务场景] 中，通过 [技术手段]，解决了 [什么问题/提升了什么指标]。*

- **话术 1 (侧重原理)**：深入理解 **...** 原理，...
- **话术 2 (侧重实战)**：在 **...** 业务中，设计了 **...** 方案，解决了 **...** 问题。

---
## 🔗 关联知识
- [[相关概念]]