| 维度         | **数据复制**                                                                         | **数据分片**                                                                                |
| :--------- | :------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------- |
| **核心问题**   | **数据有多少份副本？如何保证副本一致？**                                                           | **海量数据如何切分？切分后放在哪？**                                                                    |
| **设计目标**   | **高可用、容错、低延迟读取**                                                                 | **可扩展性、突破单机容量与性能极限**                                                                    |
| **核心方法论**  | **一致性协议**（强一致、最终一致）                                                              | **分区策略**（哈希、范围等）                                                                        |
| **核心专业词汇** | **主从复制、多主复制、无主复制<br>领导者选举、故障转移、日志复制<br>脑裂、一致性模型（线性、顺序、最终）<br>副本集、复制因子**          | **分区键、分片键、哈希环<br>协调者、路由器、元数据服务<br>数据倾斜、热点、再平衡<br>本地性、数据局部性**                            |
| **典型代表**   | **Raft, Paxos, ZAB**（强一致主从）<br>**MySQL主从, Redis主从**（异步复制）<br>**Cassandra**（无主复制） | **Kafka的Topic分区<br>Redis Cluster的哈希槽<br>Elasticsearch的分片<br>分布式数据库（TiDB, CockroachDB）** |
| **数据视图**   | 每个节点存储**全量数据**。                                                                  | 每个节点存储**数据的一个子集**。                                                                      |



| 维度        | **Leader-Based 共识算法** (Raft, ZAB)                                | **异步主从复制** (MySQL, Redis 常见模式)                                                |
| :-------- | :--------------------------------------------------------------- | :---------------------------------------------------------------------------- |
| **核心目标**  | **高可用 + 强一致**：在节点故障时，**自动、安全**地切换并保证数据零丢失、零错乱。                   | **读写分离 + 数据备份**：扩展读性能、提供数据冗余、用于分析或灾备。                                         |
| **一致性模型** | **强一致性（线性化）**：所有节点在任何时刻看到的数据顺序和值都一致。                             | **最终一致性**：主库写入后，从库数据会延迟同步，存在**数据延迟**。                                         |
| **复制机制**  | **同步复制**（多数派成功后才提交）：写请求必须被**大多数**节点持久化后，Leader才向客户端确认成功。         | **异步复制**（主库成功后即返回）：主库写入本地后立即向客户端确认成功，然后**异步**将日志传输给从库。                        |
| **故障处理**  | **自动容错与选举**：协议内建机制。Leader故障后，剩余节点能**自动、安全**地选举出新Leader，服务在秒级内恢复。 | **手动或半自动切换**：主库故障后，通常需要**人工干预**或借助外部工具（如MHA、Orchestrator）进行选主和切换，风险高、有数据丢失窗口。 |
| **数据安全**  | **优先保证**：通过“多数派提交”确保已确认的数据绝不丢失。                                  | **优先性能与可用性**：为追求主库写入性能，可能牺牲从库的即时可靠性（存在数据丢失风险）。                                |
| **节点角色**  | 动态、由协议决定：通过选举产生，角色可变化。                                           | 静态、人工配置：主从角色通常在配置文件中写死，除非手动更改。                                                |
| **CAP定位** | **CP**（一致性与分区容错）：发生网络分区时，优先保证一致性，少数派分区不可用。                       | **默认是AP**，但**可配置**：默认保证可用性（主库可写），但可通过**半同步复制**等向CP靠拢。                         |
| **典型应用**  | **分布式系统的“大脑”/“真相之源”**：如 etcd (K8s)、ZooKeeper、Consul、TiKV。        | **数据库的“扩展”与“备份”**：如 MySQL 读写分离、Redis 从库做热备或读扩展。                               |

---

### 🧱 一、核心抽象与数据模型
这些词汇定义了系统看待世界的“世界观”。

1.  **Append-Only Log (仅追加日志)**：**一切状态变更的基石**。将所有的操作、事件或数据，严格按发生顺序追加写入。它是复制、回放、审计和时间旅行的基础。`Kafka的Segment`、`MySQL的Binlog`、`Raft的Log`都基于此。 
2.  **State Machine Replication (状态机复制)**：**实现强一致的核心方法**。保证多个副本从相同的初始状态开始，**按相同顺序执行相同的操作日志**，最终达到一致的状态。这是Raft、ZAB等共识算法的目标。
3.  **Stream vs. Table (流与表)**：**数据动态性的两种视角**。
    *   **Stream**：**无限的事件序列**，关注“变化”。(Kafka的核心抽象)
    *   **Table**：**某一时刻的状态快照**，关注“当前值”。(数据库表)
    *   两者可互相转换：Table是Stream的物化视图；Stream是Table的变更日志。理解这一点就理解了 **CDC** 和 **流处理** 的根源。
4.  **Materialized View (物化视图)**：**预先计算并存储的查询结果**。通过消耗存储空间和更新成本，换取极致的查询性能。`Elasticsearch的倒排索引`、`Redis缓存`、`数据库的汇总表`都是此思想。

### ⚖️ 二、一致性、可用性与事务模式
这些词汇描述了系统在“正确性”与“可用性”间的权衡策略。

1.  **Tunable Consistency (可调一致性)**：**将一致性强度的选择权交给业务方**。这是现代分布式系统的标志性设计。
    *   `Kafka`的 **`acks`** 参数 (0, 1, all)。
    *   `Cassandra`的 **`QUORUM`** 读写级别。
    *   `Redis`的 **`WAIT`** 命令。
2.  **Quorum (法定人数)**：**实现分布式决策的数学原理**。读写操作需要成功的最小节点数。公式常为：`W + R > N` (W:写成功节点数，R:读成功节点数，N:副本总数)。保证了读写集合必有交集，从而能读到最新数据。
3.  **CRDT (无冲突复制数据类型)**：**通过数学结构设计，使数据天生可在异步复制中自动合并，无需协调**。用于AP系统实现最终一致性的高级手段，如协同编辑、计数器。
4.  **Compensating Transaction (补偿事务)** / **Saga Pattern**：**在无法提供分布式事务(如XA)的系统中，通过逆向操作“撤销”业务影响**。这是保证**最终一致性**的经典业务层模式。

### 🏗️ 三、架构与交互范式
这些词汇定义了组件如何组织与通信。

1.  **Smart Client vs. Dumb Client (智能客户端 vs. 哑客户端)**：
    *   **智能客户端**：客户端**缓存元数据、负责路由、负载均衡**。(`Redis Cluster`客户端、`Kafka`生产者)
    *   **哑客户端**：客户端只发请求，由**代理层或服务端负责路由**。(传统数据库连接、`RocketMQ` + `NameServer`)
    *   **权衡**：智能客户端性能更高、去中心化，但客户端逻辑复杂、升级困难；哑客户端反之。
2.  **Controller Pattern (控制器模式)**：**由一个中心化的“大脑”管理集群元数据和调度**。这个大脑本身通过共识算法实现高可用。`Kafka的Controller`、`Kubernetes的Controller Manager` 是典型。
3.  **Gossip Protocol (流行病协议)**：**去中心化的信息扩散方式**。节点随机选择对等节点交换信息，最终全网一致。用于**成员发现**、**故障检测** (`Redis Sentinel`、`Consul`)。
4.  **Sidecar Pattern (边车模式)**：**将通用功能（如服务发现、熔断、遥测）从应用主体剥离，作为独立进程部署在同一主机**。这是Service Mesh（如Istio）的核心理念，实现关注点分离。

### 🛠️ 四、核心工程实现与权衡
这些词汇揭示了系统在底层是如何“拧螺丝”的。

1.  **Copy-on-Write (写时复制)**：**修改数据时，不直接覆盖原数据，而是创建新副本，最后替换引用**。这是实现**无锁读取**、**快照隔离**、**数据一致性快照**的关键技术。`Git`、`Docker镜像`、`Btrfs文件系统`、`数据库MVCC`都依赖它。
2.  [[**WAL (Write-Ahead Logging，预写式日志)**]]：**任何数据修改，必须先持久化到日志中，再应用到内存或数据结构**。这是保证**持久性**和**崩溃恢复**的黄金法则。几乎所有数据库(`Redis AOF`、`MySQL Redo Log`、`PostgreSQL WAL`)和消息队列都使用它。
3.  **Read Repair & Hinted Handoff (读修复与提示移交)**：
    *   **读修复**：在读取数据时，发现副本间不一致，**主动触发修复**。(`Cassandra`)
    *   **提示移交**：写入时目标节点宕机，先将数据和“提示”交给其他节点，待目标恢复后转交。
    *   这是 **AP系统** 保证最终一致性的典型**后台修复机制**。
4.  **Vector Clock (向量时钟)**：**用于在无中心节点的情况下，检测事件发生的因果顺序**。是解决“谁先谁后”问题的分布式逻辑时钟，常用于版本冲突检测。

### 💎 如何运用这个框架进行“本质学习”与面试
**1. 分析新系统时，主动归类：**
*   听到 `etcd` -> 立刻反应：它是 **CP系统**，采用 **State Machine Replication**，核心是 **Raft共识算法** 和 **Append-Only Log**，为系统提供 **强一致的元数据存储**。
*   听到 `Cassandra` -> 立刻反应：它是 **AP系统**，采用 **无主复制**，提供 **Tunable Consistency**，通过 **Gossip** 做成员管理，用 **Read Repair** 保证最终一致。

**2. 面试中对比设计时，结构化阐述：**
> “Kafka和RocketMQ的高可用设计，本质上是 **同步复制** 和 **异步复制** 在 **持久性-延迟** 权衡上的不同选择。Kafka通过 **ISR** 和 **可调的acks机制**，实现了灵活的持久性级别；而RocketMQ则提供了 **同步/异步复制** 的配置选项，把选择权交给了业务方。两者的根本差异源于Kafka以 **流（Stream）** 为中心，而RocketMQ以 **消息（Message）** 为中心的抽象不同。”

**3. 建立技术联想：**
*   当讨论 **“如何保证不丢消息”** -> 联想到 **WAL**、**同步复制**、**Quorum写入**、**生产者确认机制**。
*   当讨论 **“如何快速故障转移”** -> 联想到 **Lease租约**、**心跳机制**、**共识选举**、**会话保持**。

掌握这些词汇，你就拥有了将任何复杂系统**降维分析**的能力。技术细节千变万化，但设计模式和权衡思想是永恒的。当你能用这套语言思考和表达时，你就已经站在了设计者的高度。